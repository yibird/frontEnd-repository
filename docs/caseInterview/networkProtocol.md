## TCP 与 UDP 的区别?

TCP(Transmission Control Protocol,传输控制协议)和 UDP(User Datagram Protocol,用户数据报协议)都属于传输层协议,其中 TCP 是一种面向连接、基于字节流通信的全双工协议,能保证端到端数据传输的可靠性;UDP 是一种不可靠且无连接基于数据报通信的协议,两者区别如下:

| TCP              | UDP                     |
| ---------------- | ----------------------- |
| 面向连接         | 无连接                  |
| 可靠性高         | 不保证可靠性,但是效率高 |
| 一次传输大量报文 | 一次传输少量报文        |
| 协议复杂         | 协议简单                |

## TCP 三次握手?

由于 TCP 提供可靠的通信机制,在传输数据之前,必须先初始化一条客户端到服务端的 TCP 连接,在连接正式建立后,双方经 TCP 连接通道进行数据传输。理论上建立传输连接只需要一个请求和一个响应。**但是,实际网络通信可能导致请求或响应丢失,可采用超时重传解决此问题,即请求或响应的丢失会造成定时器超时溢出,客户端将被迫再次发起连接请求,通过重传连接请求来建立连接,但是这样可能会导致重复连接**。为了避免这些问题,在建立 TCP 连接时采用三次握手(Three-way Handshake)方法避免建立重复连接。该方法要求对所有报文段进行编号,每次建立连接都产生一个新的初始序列号。

- 第一次握手:客户端向服务器发送一个 SYN 报文,请求建立连接。SYN 报文中含有序列号(Seq)字段,该字段指定了客户端下一次传输数据的序列号(每次握手都会产生一个新的序列号,用于防止旧的报文段被重复使用并被重新传送)。同时,客户端进入 SYN_SEND(同步发送)状态,等待服务器的确认。SYN 是一个标志位(flag),SYN=1 表示这个数据段是一个同步(SYN)报文。
- 第二次握手:服务器收到客户端的 SYN 报文后,发回一个 SYN+ACK 报文确认收到,并向客户端发送自己的 SYN 报文。SYN+ACK 报文中含有确认字段(Ack)和序列号字段(Seq),确认字段的值为客户端 SYN 报文的序列号+1,序列号字段则是服务器下一次传输数据的序列号。服务器进入 SYN_RECV(同步接收)状态。SYN 是一个标志位(flag),SYN=1 表示这个数据段是一个同步(SYN)报文。ACK 也是一个标志位(flag),ACK=1 表示这个 TCP 数据段是一个确认(ACK)数据段。
- 第三次握手:客户端收到服务器的 SYN+ACK 报文后,将确认号字段(Ack)设为服务器 SYN 报文的序列号+1,序列号字段为客户端第一次握手产生的序列号+1,并向服务器发送确认报文(ACK)。客户端进入 ESTABLISHED(建立连接)状态,表示连接已建立。

TCP 的三次握手是必须的,因为它能够确保双方的通信能够顺利进行并且可以防止一些网络问题的出现。通过三次握手,双方能够建立一个可靠的连接,使得数据能够在双方之间可靠地传输。如果只进行一次握手,服务器无法确定客户端是否收到了其发出的 SYN 数据包,也无法确定客户端的接收能力是否正常。如果只进行两次握手,那么可能会发生一些问题,例如客户端发送了一个连接请求,但是此时网络延迟较长,客户端并没有收到服务器的回复,而此时客户端直接开始发送数据,这时服务器会收到一个没有进行三次握手的连接请求,这可能会导致数据传输的错误。因此,TCP 建立连接必须进行三次握手,以确保通信的可靠性。

## TCP 四次挥手过程?

## 什么是 DNS?

## 什么是 HTTP 协议?

## HTTP 与 HTTPS 的区别?

## 说说 HTTP 缓存?

HTTP 缓存又称浏览器缓存,是指当客户端向服务器请求资源时,会先抵达浏览器缓存,如果浏览器有"要请求资源"的副本,则会从浏览器缓存中读取,从而跳过从原始服务器中读取该资源。HTTP 缓存分为协商缓存和强缓存两种:

- 强缓存:用户发送的请求,直接从用户客户端缓存读取,不发送到服务端,无需与服务端交互。命中缓存后返回 200 状态码,且 F5 刷新浏览器不会使强缓存失败。强缓存一般应用于改动较少的资源,例如图片、CSS、JavaScript 脚本等资源,该资源的请求 URL 上一般会携带一个版本号或 hash 戳用于更新强缓存。
- 协商缓存:用户发送的请求会发送到服务端,由服务端根据参数判断是否让客户端从客户端缓存读取。协商缓存无法减少请求开销,但可减少返回的正文大小。命中缓存后返回 304 状态码,F5 刷新浏览器会使强缓存失败。协商缓存需要配合强缓存使用,如果不启用强缓存的话,协商缓存根本没有意义。

强制缓存在缓存数据未失效的情况下(即 Cache-Control 的 max-age 没有过期或者 Expires 的缓存时间没有过期),那么就会直接使用浏览器的缓存数据,不会再向服务器发送任何请求。强制缓存生效时,http 状态码为 200。这种方式页面的加载速度是最快的,性能也是很好的,但是在这期间,如果服务器端的资源修改了,则无法获取到最新的资源,因为它不会再向服务器发请求了。
强缓存可通过请求头的 Pragma、Cache-Control、Expires 设置:

- Pragma:Pragma 是一个在 HTTP/1.0 中规定的通用首部,这个首部的效果依赖于不同的实现,所以在"请求-响应"链中可能会有不同的效果。它用来向后兼容只支持 HTTP/1.0 协议的缓存服务器,那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来。
- Cache-Control:通用消息头字段,被用于在 HTTP 请求和响应中,通过指定指令来实现缓存机制。缓存指令是单向的,这意味着在请求中设置的指令,不一定被包含在响应中。
- Expires:用于设置资源过期时间(一个 GMT 时间),如果在 Cache-Control 响应头设置了 "max-age" 或者 "s-max-age" 指令,那么 Expires 头会被忽略。

当第一次请求时服务器返回的响应头中没有 Cache-Control 和 Expires,或者 Cache-Control 和 Expires 过期及它的属性设置为 no-cache 时(即不走强缓存),那么浏览器第二次请求时就会与服务器进行协商,与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改(通过 Etag/If-None-Match 和 Last-Modified/If-Modified-Since 作为缓存判断依赖),那么就会返回 304 状态码,告诉浏览器可以使用缓存中的数据,这样就减少了服务器的数据传输压力。如果数据有更新就会返回 200 状态码,服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的 header 头属性有(ETag/If-None-Match 、Last-Modified/If-Modified-Since)请求头和响应头需要成对出现,ETag/If-None-Match 是根据请求资源内容是否变化来判断是否命中缓存,而 Last-Modified/If-Modified-Since 则根据请求资源根据最后修改时间来判断是否命中缓存。

- Etag:Etag 是 HTTP 响应头是资源的特定版本的标识符,一般是一个 hash 戳,用于描述资源的内容。Etag 可以让缓存更高效,并节省带宽，因为如果内容没有改变,Web 服务器不需要发送完整的响应。而如果内容发生了变化.使用 ETag 有助于防止资源的同时更新相互覆盖。
- If-None-Match:If-None-Match 是一个条件式请求首部。对于 GETGET 和 HEAD 请求方法来说,当且仅当服务器上没有任何资源的 ETag 属性值与 If-None-Match 相匹配的时候,服务器端才会返回所请求的资源,响应码为 200 。如果 Etag 与 If-None-Match 相匹配时则返回从缓存中返回资源,并响应 304 状态码。
- Last-Modified:资源最后一次修改时间。
- If-Modified-Since:是一个条件式请求首部。是上一次的 Last-Modified。

## HTTP/2 有哪些特性?

HTTP/2 于 2015 年发布,是 HTTP/1.1 的继任者,改进了 HTTP1.1 性能和安全问题。HTTP2.0 主要特性如下:

- 二进制分帧传输。HTTP1.1 是一个文本协议,虽然可读性好易于调试,但传输内容体积也更大,HTTP2.0 为了优化传输效率,采用二进制形式。HTTP2.0 请求与响应数据被分割更小的二进制帧(frames,帧是最小的数据单位,每个帧都包含一个特定类型的数据块),而不再使用文本形式传输。在 HTTP2.0 中,多个帧之间可以乱序发送,根据帧首部的流可以进行重新组装。
- 引入了流(Stream)的概念。HTTP/2 中引入了流的概念,每个流都是一个独立的双向通信通道,可以用来传输帧。多个流可以在同一个连接上并行传输,而不会相互干扰。流可以根据优先级进行排序,以确保重要数据的及时传输。
- 多路复用。HTTP/2 使用单个连接来处理多个请求和响应,而不需要在每次请求之后建立新连接。这降低了连接建立和断开的开销。在 HTTP/1.1 中,浏览器和服务器之间的每个请求都需要一个独立的连接。这意味着在下载多个资源时,浏览器必须同时打开多个连接,这会导致连接的延迟和资源浪费。而 HTTP/2 中的多路复用允许多个请求和响应在单个连接上并行传输,减少了连接产生的开销,提升了通信效率。
- 支持头部压缩。在 HTTP1.X 中,HTTP 头都是以纯文本的形式发送的,通常会给每个请求增加 500-8000 字节的负荷,造成不必要带宽浪费和资源消耗。例如 cookie,默认情况下,浏览器会在每次请求的时候,把 cookie 附在 header 上面发给服务器。HTTP2 中为了减少传输不必要的请求头,使用 HPACK 压缩算法来减小请求和响应头部的大小,避免额外的带宽浪费,从而提升传输效率。
- 支持服务器推送。HTTP/2.0 的服务器推送(Server Push)是一项强大的特性,它允许服务器在客户端请求之前主动向客户端推送额外的资源。HTTP2 服务器推送的工作原理如下:
  - 当客户端发起对某个资源的请求时,服务器可以检查该请求所对应的页面或资源,并判断哪些其他资源可能会被客户端在不久的将来请求。
  - 服务器可以主动将这些附加资源推送到客户端,以帮助客户端更快地加载页面。服务器会在响应头部使用特殊的 PUSH_PROMISE 帧来标识推送资源,并在后续的帧中传送这些资源。
  - 客户端可以选择接受或拒绝服务器推送的资源。如果客户端已经有了相同资源的本地副本,它可以拒绝接受推送的资源。
- 支持流量优先级(Stream Prioritization)。HTTP/2 允许客户端指定请求的优先级,以确保重要资源优先加载。

## HTTP GET 与 POST 请求的区别?

GET 和 POST 是 HTTP 最主要的两个请求,其区别如下:

- 传输参数位置:GET 请求将传输参数附加在 URL 的末尾,通常以问号（?）开始,参数之间使用“&”符号分隔。而 POST 请求将数据包含在请求的请求体中。
- 应用场景:GET 请求用于从服务器获取数据,通常用于读取资源,如查看网页、下载文件、获取搜索结果等,因此 GET 请求是幂等的。POST 主要用于向服务器提交数据,执行对服务器状态的修改或进行其他需要数据传输的操作,因此是非幂等性的。
- 安全性:由于 GET 请求的参数以明文形式显示在 URL 中,因此不适合传输敏感信息,安全性比较差。而 POST 请求传输的数据包含在请求体中,并不会明文显示在 URL 中,因此安全性更高。此外,可以使用 HTTPS 来加密 POST 请求的数据,提高安全性。
- 缓存:GET 请求可以被浏览器缓存,以提高性能和减少重复请求。POST 请求默认情况下不会被浏览器缓存,因为它们通常会产生副作用,如修改服务器上的数据。

## HTTP 常用状态码有哪些?

- 100(Continue)。100 状态码表示请求继续,客户端应继续其请求。
- 101(Switching Protocols)。101 状态码表示切换协议。服务器根据客户端的请求切换协议,只能切换到更高级的协议,例如切换到 HTTP 的新版本协议。
- 200(OK)。200 状态码表示请求成功。一般用于 GET 与 POST 请求。
- 204(No Content)。204 状态码表示无内容。服务器成功处理,但未返回内容。在未更新网页的情况下,可确保浏览器继续显示当前文档。
- 301(Moved Permanently)。301 状态码表示永久移动。请求的资源已被永久的移动到新 URI,返回信息会包括新的 URI,浏览器会自动定向到新 URI,今后任何新的请求都应使用新的 URI 代替。
- 302(Found)。302 状态码表示临时移动。与 301 类似,但资源只是临时被移动,客户端应继续使用原有 URI。
- 304(Not Modified)。304 状态码表示未修改,所请求的资源未修改,服务器返回此状态码时,不会返回任何资源。客户端通常会缓存访问过的资源,通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
- 307(Temporary Redirect)。307 状态码表示临时重定向,与 302 类似,使用 GET 请求重定向。
- 400(Bad Request)。400 状态码表示客户端请求的语法错误,服务器无法理解。
- 401(Unauthorized)。401 状态码表示请求要求用户的身份认证。
- 403(Forbidden)。403 状态码表示服务器理解请求客户端的请求,但是拒绝执行此请求。
- 500(Internal Server Error)。500 状态码表示服务器内部错误,无法完成请求。
- 502(Bad Gateway)。502 状态码表示错误网关。作为网关或者代理工作的服务器尝试执行请求时,从远程服务器接收到了一个无效的响应。
- 504(Gateway Time-out)。504 表示网关超时,充当网关或代理的服务器,未及时从远端服务器获取请求。
