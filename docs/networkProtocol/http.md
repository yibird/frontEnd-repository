### HTTP 协议历史背景

HTTP 是超文本传输协议(Hyper Text Transfer Protocol)的英文简称,HTTP 是一个简单的请求-响应协议,它通常运行在 TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出;而消息内容则具有一个类似 MIME 的格式。这个简单模型是早期 Web 成功的有功之臣,因为它使开发和部署非常地直截了当。HTTP 是应用层协议,同其他应用层协议一样,是为了实现某一类具体应用的协议,并由某一运行在用户空间的应用程序来实现其功能。HTTP 是一种协议规范,这种规范记录在文档上,为真正通过 HTTP 进行通信的 HTTP 的实现程序。HTTP 的发展历史如下:

- 0.9 版本。0.9 版本的 HTTP 协议就是一个交换信息的无序协议,仅仅限于文字。由于无法进行内容的协商,在双发的握手和协议中,并有规定双发的内容是什么,也就是图片是无法显示和处理的。
- 1.0 版本。到了 1.0 协议阶段,也就是在 1982 年,Tim Berners-Lee 提出了 HTTP/1.0。在此后的不断丰富和发展中,HTTP/1.0 成为最重要的面向事务的应用层协议。该协议对每一次请求/响应建立并拆除一次连接。其特点是简单、易于管理,所以它符合了大家的需要,得到了广泛的应用。
- 1.1 版本。在 1.0 协议中,双方规定了连接方式和连接类型,这已经极大扩展了 HTTP 的领域,但对于互联网最重要的速度和效率,并没有太多的考虑。毕竟,作为协议的制定者,当时也没有想到 HTTP 会有那么快的普及速度。目前大多数网站都是基于 HTTP1.1 版本。
- 2.0 版本。HTTP2.0 的前身是 HTTP1.0 和 HTTP1.1。虽然之前仅仅只有两个版本,但这两个版本所包含的协议规范之庞大,足以让任何一个有经验的工程师为之头疼。网络协议新版本并不会马上取代旧版本。实际上,1.0 和 1.1 在之后很长的一段时间内一直并存,这是由于网络基础设施更新缓慢所决定的。

### HTTP 2.0 对于 HTTP 1.x 有哪些优点？

- 多路复用。多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。由于 http 1.x 的时代中,浏览器向同一域名下发送的 http 请求数量是受限的,当超出数量限制时,请求会被阻塞,大大降低了用户体验。而 HTTP/2 的多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
- 二进制分帧。HTTP/2 在应用层和传输层之间追加了一个二进制分帧层,最终使得多个数据流共用一个连接,更加高效的使用 tcp 连接。从而使得服务器的连接压力减轻,降低了内存的消耗,增大了网络的吞吐量。
- 首部压缩。HTTP/2 引入了 HPACK 算法对头部进行压缩,大大减小了数据发送的字节数。

### HTTP 的组成部分

### HTTP 状态码

HTTP 状态码由三个十进制数字组成,第一个十进制数字定义了状态码的类型。响应分为五类:信息响应(100–199),成功响应(200–299),重定向(300–399),客户端错误(400–499)和服务器错误(500–599):
|分类 | 描述 |
|-|-|
|1**|信息,服务器收到请求,需要请求者继续执行操作|
|2**|成功,操作被成功接收并处理|
|3**|重定向,需要进一步的操作以完成请求|
|4**|客户端错误,请求包含语法错误或无法完成请求|
|5\*\*|服务器错误,服务器在处理请求的过程中发生了错误|

HTTP 状态码列表:
| 状态码 |状态码英文名称| 描述 |
|-|-|-|
|100|Continue|继续。客户端应继续其请求|
|101|Switching Protocols|切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议|
|200|OK|请求成功。一般用于 GET 与 POST 请求|
|201|Created|已创建。成功请求并创建了新的资源|
|202|Accepted|已接受。已经接受请求,但未处理完成|
|203|Non-Authoritative Information|已创建。成功请求并创建了新的资源|
|204|No Content|无内容。服务器成功处理，但未返回内容。在未更新网页的情况下,可确保浏览器继续显示当前文档|
|205|Reset Content|重置内容。服务器处理成功，用户终端(例如:浏览器)应重置文档视图。可通过此返回码清除浏览器的表单域|
|206|Partial Content| 部分内容。服务器成功处理了部分 GET 请求|
|300| Multiple Choices| 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如:浏览器）选择|
|301| Moved Permanently| 永久移动。请求的资源已被永久的移动到新 URI,返回信息会包括新的 URI,浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替|
|302| Found| 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI|
|303| See Other| 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看|
|304| Not Modified| 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源|
|305 |Use Proxy| 使用代理。所请求的资源必须通过代理访问|
|306 |Unused| 已经被废弃的 HTTP 状态码|
|307 |Temporary Redirect |临时重定向。与 302 类似。使用 GET 请求重定向|
|400 |Bad Request| 客户端请求的语法错误，服务器无法理解|
|401 |Unauthorized| 请求要求用户的身份认证|
|402 |Payment Required| 保留,将来使用|
|403 |Forbidden| 服务器理解请求客户端的请求,但是拒绝执行此请求|
|404 |Not Found| 服务器无法根据客户端的请求找到资源(网页)。通过此代码,网站设计人员可设置"您所请求的资源无法找到"的个性页面|
|405 |Method Not Allowed| 客户端请求中的方法被禁止|
|406 |Not Acceptable|服务器无法根据客户端请求的内容特性完成请求|
|407 |Proxy Authentication Required| 请求要求代理的身份认证，与 401 类似,但请求者应当使用代理进行授权|
|408 |Request Time-out| 服务器等待客户端发送的请求时间过长,超时|
|409 |Conflict| 服务器完成客户端的 PUT 请求时可能返回此代码,服务器处理请求时发生了冲突|
|410 |Gone| 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置|
|411 | Length Required| 服务器无法处理客户端发送的不带 Content-Length 的请求信息|
|412 | Precondition Failed| 客户端请求信息的先决条件错误|
|413| Request Entity Too Large| 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理,则会包含一个 Retry-After 的响应信息|
|414| Request-URI Too Large| 请求的 URI 过长(URI 通常为网址),服务器无法处理|
|415| Unsupported Media Type| 服务器无法处理请求附带的媒体格式|
|416| Requested range not satisfiable| 客户端请求的范围无效|
|417| Expectation Failed| 服务器无法满足 Expect 的请求头信息|
|500| Internal Server Error| 服务器内部错误，无法完成请求|
|501| Not Implemented| 服务器不支持请求的功能，无法完成请求|
|502| Bad Gateway| 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
|503| Service Unavailable| 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中|
|504| Gateway Time-out| 充当网关或代理的服务器，未及时从远端服务器获取请求|
|505| HTTP Version not supported| 服务器不支持请求的 HTTP 协议的版本，无法完成处理|

### GET 请求与 POST 请求的区别?

- POST 请求相比较 GET 请求更加安全。由于 GET 请求的参数会作为 URL 的一部分,且会被缓存保存在服务器日志及浏览器浏览器记录中,而 POST 请求则不会。
- POST 发送的数据更大。由于 GET 请求发送的数据包含在请求 URL 中,一般 URL 限制长度是 2KB 左右,而 POST 请求将请求数据包含在请求体中,HTTP 并没有限制请求体的长度,这意味着可以传输任意大小的数据。POST 请求能发送更多的数据类型,GET 请求只能发送 ASCII 字符。
- POST 请求用于写入、修改操作,GET 请求用于查询检索操作,在 GET 请求下若请求资源是静态资源,那么会进行缓存,如果请求资源是数据则不会缓存。
- POST 请求会产生两个 TCP 数据包,而 GET 请求仅会产生一个 TCP 数据包,所以 POST 请求比 GET 请求更慢。POST 请求下浏览器先发送 header,服务器响应 100 continue 后,浏览器再发送 data,服务器响应 200 OK(返回数据)。注意并不是所有浏览器都会在 POST 请求中发送两次数据包,Firefox 就只发送一次。
