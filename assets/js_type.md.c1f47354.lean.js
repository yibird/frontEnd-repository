import{_ as n,c as a,e as l,a as s,o}from"./app.1f2ef310.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"1.基本类型与引用类型的区别","slug":"_1-基本类型与引用类型的区别","link":"#_1-基本类型与引用类型的区别","children":[{"level":3,"title":"扩展:栈内存相较于堆内存的优点:","slug":"扩展-栈内存相较于堆内存的优点","link":"#扩展-栈内存相较于堆内存的优点","children":[]},{"level":3,"title":"扩展:JS 栈溢出产生原因及解决方法","slug":"扩展-js-栈溢出产生原因及解决方法","link":"#扩展-js-栈溢出产生原因及解决方法","children":[]}]},{"level":2,"title":"2.类型判断","slug":"_2-类型判断","link":"#_2-类型判断","children":[{"level":3,"title":"2.1 typeof","slug":"_2-1-typeof","link":"#_2-1-typeof","children":[]},{"level":3,"title":"2.2 instanceof","slug":"_2-2-instanceof","link":"#_2-2-instanceof","children":[]},{"level":3,"title":"2.4 类型判断的几种方式","slug":"_2-4-类型判断的几种方式","link":"#_2-4-类型判断的几种方式","children":[]},{"level":3,"title":"2.4 总结","slug":"_2-4-总结","link":"#_2-4-总结","children":[]}]},{"level":2,"title":"3.类型转换","slug":"_3-类型转换","link":"#_3-类型转换","children":[{"level":3,"title":"3.1 隐式转换类型","slug":"_3-1-隐式转换类型","link":"#_3-1-隐式转换类型","children":[]},{"level":3,"title":"3.2 == 与 ===的区别?","slug":"_3-2-与-的区别","link":"#_3-2-与-的区别","children":[]},{"level":3,"title":"3.3 显示类型转换","slug":"_3-3-显示类型转换","link":"#_3-3-显示类型转换","children":[]}]},{"level":2,"title":"4.JavaScript 中浮点数精度问题","slug":"_4-javascript-中浮点数精度问题","link":"#_4-javascript-中浮点数精度问题","children":[{"level":3,"title":"4.1 JS 浮点数精度产生原因","slug":"_4-1-js-浮点数精度产生原因","link":"#_4-1-js-浮点数精度产生原因","children":[]},{"level":3,"title":"4.2 JS 浮点数精度问题解决方法","slug":"_4-2-js-浮点数精度问题解决方法","link":"#_4-2-js-浮点数精度问题解决方法","children":[]}]},{"level":2,"title":"5.Symbol 与 BigInt","slug":"_5-symbol-与-bigint","link":"#_5-symbol-与-bigint","children":[{"level":3,"title":"5.1 Symbol","slug":"_5-1-symbol","link":"#_5-1-symbol","children":[]},{"level":3,"title":"5.2 BigInt","slug":"_5-2-bigint","link":"#_5-2-bigint","children":[]}]}],"relativePath":"js/type.md","lastUpdated":1677483206000}'),p={name:"js/type.md"},t=s("",12),e=s("",86);function c(r,y,D,F,A,C){return o(),a("div",null,[t,l(' 函数调用会在内存形成一个"调用记录",又称"调用帧"(call frame),保存调用位置和内部变量等信息。函数在内部调用该函数本身被称为递归,而递归是极为消耗内存的,因为需要同时保存成千上百个调用帧,很容易发生"栈溢出"错误(stack overflow)。对于递归调用可以通过 ES6 提供的尾递归来节省所耗用的栈空间。 '),e])}const f=n(p,[["render",c]]);export{u as __pageData,f as default};
