import{_ as a,c as i,o as l,ae as o}from"./chunks/framework.C7gvd0FP.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"microFrontEnd/introduction.md","filePath":"microFrontEnd/introduction.md","lastUpdated":1764669646000}'),r={name:"microFrontEnd/introduction.md"};function t(n,e,d,p,s,u){return l(),i("div",null,[...e[0]||(e[0]=[o('<p>随着前端技术的发展,单页面应用(SPA)变得越来越普及。然而,随着应用程序的规模和复杂性的增加,单一的前端代码库变得难以维护和扩展。大规模应用的开发、维护和部署面临以下挑战：</p><ul><li>代码库庞大:随着功能的增加,代码库变得庞大,构建时间和部署时间增加,开发效率降低。</li><li>团队协作困难:多个团队在同一个代码库中工作,容易导致合并冲突、依赖关系复杂化以及发布周期延长。</li><li>技术栈限制:单一的前端技术栈限制了团队选择最适合的技术来实现特定功能。</li><li>渐进式迁移:难以逐步迁移老旧的代码库到新的技术栈或架构,通常需要一次性大规模重构。</li></ul><p>为了应对这些挑战,微前端（Micro Frontends）概念应运而生。微前端借鉴了微服务分而治之的的思想,将前端应用拆分成多个独立的小应用,每个小应用可以由不同的团队开发、测试和部署,最终通过某种方式(例如,容器应用,也叫做基座应用)将它们组合成一个整体的用户界面。使用微前端具有如下优点:</p><ul><li>技术栈独立:不同的微前端应用可以使用不同的技术栈,允许团队选择最适合的工具和框架。</li><li>独立开发和部署:每个微前端应用可以独立开发、测试和部署,减少了不同团队之间的依赖和冲突。</li><li>提升可维护性和可扩展性:应用拆分为更小的部分,每个部分的复杂度降低,提高了代码的可维护性和可扩展性。</li></ul><h2 id="_1-使用微前端产生的问题" tabindex="-1">1.使用微前端产生的问题 <a class="header-anchor" href="#_1-使用微前端产生的问题" aria-label="Permalink to &quot;1.使用微前端产生的问题&quot;">​</a></h2><ul><li><p>通讯和状态管理。在微前端架构中,多个子应用可能需要共享状态或相互通讯,这会导致状态管理复杂化,由于子应用使用的技术栈有所差异,与框架强耦合的全局(Pinia、Redux)状态并不能满足微前端场景,因此主应用和子应用之间需要一种机制来共享数据和事件,如事件总线(Event Bus)、RPC调用或状态管理解决。</p></li><li><p>JS与样式隔离。不同子应用可能会使用相同的库或样式表,导致冲突。对于CSS可以通过Shadow DOM或样式前缀(以应用名为前缀)来隔离样式;对于JS一般通过JS沙箱来隔离,JS沙箱一般有以下几种实现方式:</p><ul><li>基于Proxy。使用 JavaScript 的 Proxy 对象来拦截和代理对子应用的全局对象(如 window、document)的访问,从而实现隔离。这种方式性能较好且具有不错隔离性,但是实现复杂,而且存在着一定兼容性问题。在qiankun中提供了快照沙箱和Proxy沙箱两种,如果当前环境不支持Proxy,则会降级为快照沙箱。快照沙箱(Snapshot Sandbox)是一种通过保存和恢复全局状态来实现隔离的技术。它的核心思想是在子应用挂载时保存当前的全局状态快照,在子应用卸载时将全局状态恢复到快照状态,从而避免不同子应用之间的相互干扰。</li><li>基于eval函数。使用 JavaScript 的 eval 函数或 new Function 创建的隔离环境来执行子应用的代码,从而实现隔离。这种方式实现简单,但性能较差,存在被注入攻击的风险。</li></ul></li><li><p>预加载。在浏览器空间时加载子应用,以提升子应用首次加载效率。主应用可以利用requestIdleCallback()在浏览器空间时预加载子应用。</p></li><li><p>公共依赖问题。多个子应用可能会依赖相同的库,导致重复加载和版本冲突。一般将公共依赖提升至主应用或使用Module Federation(模块联邦)来共享依赖。</p></li><li><p>路由的管理。由于各个子应用可能有各自的路由系统,主应用需要提供一套路由系统,当路由发生变化时,主应用拦截路由url并匹配对于的子应用。</p></li><li><p>子应用保活。在微前端架构中,子应用可能会不停切换,为了避免页面状态丢失,子应用需要在不同页面之间进行保活(保持其状态和数据)。</p></li><li><p>子应用相互嵌套。子应用之间的嵌套可能会导致复杂的依赖关系和性能问题。s</p></li><li><p>生命周期设计。微前端中的每个子应用需要定义和管理自己的生命周期钩子,以确保正确加载和卸载。</p></li></ul><h2 id="_2-微前端四种主流实现方式" tabindex="-1">2.微前端四种主流实现方式 <a class="header-anchor" href="#_2-微前端四种主流实现方式" aria-label="Permalink to &quot;2.微前端四种主流实现方式&quot;">​</a></h2><h3 id="_2-1-iframe" tabindex="-1">2.1 iframe <a class="header-anchor" href="#_2-1-iframe" aria-label="Permalink to &quot;2.1 iframe&quot;">​</a></h3><p>iframe 是HTML中的一个标签，全称为“Inline Frame”，即内联框架。它允许在一个网页中嵌入另一个完整的HTML文档.通常用于在当前页面内加载和显示来自其他来源的内容。iframe天然支持html Entry、资源隔离(JS、CSS、DOM隔离)、子应用嵌套,是实现微前端的最简单的一种方案,但iframe存在着如下缺点:</p><ul><li>通信机制复杂。在iframe 无论使用postMessage无论还是通过 iframeEl.contentWindow 去获取 iFrame 元素的 Window 对象,⼜或者是直接⽗⻚⾯调⽤⼦⻚⾯⽅法：FrameName.window.childMethod();⼦⻚⾯调⽤⽗⻚⾯⽅法：parent.window.parentMethod();通信机制比较复杂。</li><li>刷新页面路由状态丢失。一旦刷新页面,会导致iframe 的 url 状态丢失。</li><li>DOM 割裂严重。弹窗只能在 iframe 内部展示,无法覆盖全局,并且事件传递上存在者很大的问题,例如拖拽。</li><li>容易造成白屏且不支持预加载。iframe url的HTTP请求会增加页面加载时间,尤其是在网络条件不佳的情况下,容易造成白屏,而且iframe也不支持应用预加载。</li><li>不支持应用保活。每次加载应用都会重新拉取资源。</li></ul><h3 id="_2-2-web-components" tabindex="-1">2.2 Web Components <a class="header-anchor" href="#_2-2-web-components" aria-label="Permalink to &quot;2.2 Web Components&quot;">​</a></h3><h3 id="_2-3-single-spa" tabindex="-1">2.3 single-spa <a class="header-anchor" href="#_2-3-single-spa" aria-label="Permalink to &quot;2.3 single-spa&quot;">​</a></h3><h3 id="_2-4-module-federation" tabindex="-1">2.4 module Federation <a class="header-anchor" href="#_2-4-module-federation" aria-label="Permalink to &quot;2.4 module Federation&quot;">​</a></h3><p>模块联邦(Module Federation)是 Webpack 5 引入的一项新特性,旨在解决微前端架构中模块共享和依赖管理的问题。模块联邦允许多个独立构建和部署的应用程序(或模块)共享代码,从而实现更高效的代码复用和独立发布。</p>',14)])])}const h=a(r,[["render",t]]);export{c as __pageData,h as default};
