import{_ as e,o as t,c as a,Q as i}from"./chunks/framework.a9ea851b.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"react/interview.md","filePath":"react/interview.md","lastUpdated":1694587313000}'),l={name:"react/interview.md"},r=i('<h3 id="react-是什么" tabindex="-1">React 是什么? <a class="header-anchor" href="#react-是什么" aria-label="Permalink to &quot;React 是什么?&quot;">​</a></h3><p>React 是 FB 开源的前端 JavaScript 库,以 JSX 的形式构建用户界面,尤其是单页应用程序,React 具有如下特点:</p><ul><li>考虑到 RealDOM 操作成本高昂,它使用 虚拟 DOM(VirtualDOM) 而不是 真实 DOM(RealDOM)。</li><li>支持服务端渲染。</li><li>遵循单向数据流或数据绑定。</li><li>使用可重用/可组合的 UI 组件来开发视图。</li></ul><h3 id="react-函数式组件与-class-组件的区别" tabindex="-1">React 函数式组件与 Class 组件的区别? <a class="header-anchor" href="#react-函数式组件与-class-组件的区别" aria-label="Permalink to &quot;React 函数式组件与 Class 组件的区别?&quot;">​</a></h3><p>class 组件是指通过 ES6 class 并继承 React.Component 创建的类,class 组件又称为有状态组件(内部含有私有的 State),在 class 组件中可以访问 this、state、ref、组件的生命周期。</p><p>函数式组件是通过函数形式定义的组件,又被称为无状态组件(内部没有私有的 State),由于函数式组件不会被实例化,所以整体渲染性能得到提升,函数式组件不能访问 this 对象和组件生命周期函数(但可以通过 Hook 模拟生命周期函数),所以 this.state、this.ref 都无法访问。</p><h3 id="react-组件生命周期-基于-react17" tabindex="-1">React 组件生命周期(基于 React17) <a class="header-anchor" href="#react-组件生命周期-基于-react17" aria-label="Permalink to &quot;React 组件生命周期(基于 React17)&quot;">​</a></h3><ul><li>constructor:组件的构造函数,在初始化调用,只会调用一次。一般在此函数完成一些初始化工作,例如初始化 state、绑定事件 this 等等操作。</li><li>static getDerivedStateFromProps:组件 render 之前调用,在初次挂载和后续更新都会调用。它是一个静态方法,它可以返回一个对象来更新 state,如果返回 null 则不更新任何内容。</li><li>render:组件渲染元素时执行,一旦组件所依赖的数据发生变化就会执行此函数。</li><li>componentDidMount:组件挂载到页面时执行,在 render 函数之后执行,只会执行一次,在此函数可以完成网络请求等操作。</li><li>shouldComponentUpdate:组件更新数据前执行,它返回一个布尔值,该函数是 React 的优化项,用于控制组件是否重新渲染。</li><li>getSnapshotBeforeUpdate:此钩子函数在 render 函数之后 componentDidUpdate 之前执行,它的返回值可以将作为 componentDidUpdate 钩子函数的第三个参数。</li><li>componentDidUpdate:组件更新数据时执行,此钩子函数在 getSnapshotBeforeUpdate 后调用,第三个的参数的值来源于 getSnapshotBeforeUpdate 钩子函数返回的值。</li><li>componentWillUnmount:组件在销毁卸载时执行,可以在此函数可以清除定时器,释放资源等操作。</li><li>static getDerivderStateFromError:此生命周期会在渲染阶段后代组件抛出错误后被调用,它将抛出的错误作为参数,并返回一个值以更新 state。</li><li>componentDidCatch:此生命周期在后代组件抛出错误后被调用。</li></ul><p>组件的生命周期分为挂载、更新、卸载、错误处理 4 个过程,对应的生命周期:</p><ul><li>挂载相关钩子函数:constructor、static getDerivedStateFromProps、render、componentDidMount。</li><li>更新相关钩子函数:static getDerivedStateFromProps、shouldComponentUpdate、render、getSnapshotBeforeUpdate、componentDidUpdate。</li><li>卸载相关钩子函数:componentWillUnmount。</li><li>错误处理相关钩子函数:static getDerivderStateFromError、componentDidCatch。</li></ul><h3 id="在-react-class-组件中添加事件后为什么要绑定-this" tabindex="-1">在 React class 组件中添加事件后为什么要绑定 this? <a class="header-anchor" href="#在-react-class-组件中添加事件后为什么要绑定-this" aria-label="Permalink to &quot;在 React class 组件中添加事件后为什么要绑定 this?&quot;">​</a></h3><p>React 的事件处理大致可分为 bind()绑定和箭头函数两种,之所以在类组件中使用 bind()绑定当前组件 this 是因为函数 this 指向问题,在 JavaScript 中函数的 this 取决于函数的调用环境,而不是函数的声明环境,如果事件处理函数不绑定到当前组件 this,那么 this 最终指向的是 undefined,而不是组件本身。</p><h3 id="react-组件通讯" tabindex="-1">React 组件通讯 <a class="header-anchor" href="#react-组件通讯" aria-label="Permalink to &quot;React 组件通讯&quot;">​</a></h3><ul><li>通过 props 父传子。</li><li>通过 props+回调函数子传父。</li><li>通过 ref 获取元素实例。</li><li>通过 Context 实现跨层级组件通讯。</li><li>第三方状态管理库。例如 Redux、Mobx、Recoil、Unstated 等等。</li><li>使用发布订阅模式实现跨组件通讯。</li><li>Web Storage 实现跨组件通讯。</li></ul><h3 id="什么是高阶组件" tabindex="-1">什么是高阶组件? <a class="header-anchor" href="#什么是高阶组件" aria-label="Permalink to &quot;什么是高阶组件?&quot;">​</a></h3><p>高阶组件(HOC)是一个函数,它接收一个组件作为参数或返回一个新的组件(跟高阶函数是类似的)。基本上,HOC 是一种源自 React 组合性质的模式。HOC 又被称为纯组件,因为它可以接受任何动态提供的子组件,但不会修改或复制其输入组件的任何行为。HOC 的应用场景:</p><ul><li>代码重用、逻辑和引导程序抽象。</li><li>渲染劫持。</li><li>状态抽象和操作。</li><li>props 操纵。</li></ul><h3 id="为什么-fragment-比-div-容器更好" tabindex="-1">为什么 Fragment 比 Div 容器更好? <a class="header-anchor" href="#为什么-fragment-比-div-容器更好" aria-label="Permalink to &quot;为什么 Fragment 比 Div 容器更好?&quot;">​</a></h3><ul><li>Fragment 不会创建额外的 DOM 节点,Fragment 会更快一些并且使用更少的内存,这只对非常大和深的树有真正的好处。</li><li>一些 CSS 机制如 Flexbox 和 CSS Grid 具有特殊的父子关系,并且在中间添加 div 很难保持所需的布局。</li><li>DOM Inspector(检查工具) 不那么杂乱。</li></ul><h3 id="react-中合成事件是什么-有什么优点" tabindex="-1">React 中合成事件是什么?有什么优点? <a class="header-anchor" href="#react-中合成事件是什么-有什么优点" aria-label="Permalink to &quot;React 中合成事件是什么?有什么优点?&quot;">​</a></h3><h3 id="this-setstate-是同步的还是异步的" tabindex="-1">this.setState()是同步的还是异步的? <a class="header-anchor" href="#this-setstate-是同步的还是异步的" aria-label="Permalink to &quot;this.setState()是同步的还是异步的?&quot;">​</a></h3><p>setState 更新可分为如下两种情况:</p><ul><li>在组件生命周期函数或 React 合成事件中,setState()是异步更新的。</li><li>在 setTimeout 或原生 DOM 事件中,setState 是同步更新的。</li></ul><p>setState()之所以被设计为异步的原因:如果每次调用 setState()进行更新,那么意味着 render 函数会被频繁的调用界面渲染,这样会导致效率很低效。最好的办法就是获取到多个 setState()更新,之后进行批量更新,减少组件频繁 render。所以 setState()被设计为异步是出于对性能的考量,异步下的 setState()能减少组件 render 次数,提高渲染性能。</p><p>获取 setState()异步更新 state 后的结果值:</p><ul><li>通过 setState()的回调函数获取。setState 接收两个参数,第二个参数是一个回调函数,该回调函数在 state 更新后被执行。</li><li>通过 componentDidUpdate 生命钩子函数,该钩子函数执行时机是在 State 更新后。</li></ul><h3 id="使用-hooks-的注意事项" tabindex="-1">使用 Hooks 的注意事项 <a class="header-anchor" href="#使用-hooks-的注意事项" aria-label="Permalink to &quot;使用 Hooks 的注意事项&quot;">​</a></h3><h3 id="this-setstate-与-usestate-的区别" tabindex="-1">this.setState()与 useState()的区别? <a class="header-anchor" href="#this-setstate-与-usestate-的区别" aria-label="Permalink to &quot;this.setState()与 useState()的区别?&quot;">​</a></h3><ul><li>useState 生成的 State 相比较类组件的 State 粒度更细。</li><li>useState 生成的 State 保存是快照(底层由闭包实现,当组件重新渲染时快照也会被重置),而类组件的 State 保存是最新值(因为类组件会被实例化且不能被销毁,所以 State 是一个引用)。useState 可以结合 useRef 获取 State 最新值。</li><li>在引用类型下,Class State 无需传入新的引用,而 useState 必须保证是一个新的引用。</li></ul><h3 id="useref-与-createref-的区别" tabindex="-1">useRef()与 createRef()的区别? <a class="header-anchor" href="#useref-与-createref-的区别" aria-label="Permalink to &quot;useRef()与 createRef()的区别?&quot;">​</a></h3><p>useRef()是 React16.8 提供用于操作 ref 的 Hook,useRef 具有如下特点:</p><ul><li>useRef 是一个只能用于函数式组件的方法。</li><li>useRef 是除字符串 ref、函数 ref、createRef 以外的第四种获取 Ref 的方法。</li><li>useRef 在函数渲染周期内永远不会变,因此可以引用某些数据。</li><li>修改 Ref.current 不会引发组件重新渲染。</li></ul><p>useRef()与 createRef()区别如下:</p><ul><li>useRef 和 createRef 都能获取 Ref。</li><li>useRef 只能用于函数式组件,而 createRef 既能用于函数式组件,又可以用在类组件。</li><li>useRef 在每次渲染后都保持不变,而 createRef 在每次渲染后都会发生变化。</li></ul><h3 id="useeffect-与-uselayouteffect-的区别" tabindex="-1">useEffect()与 useLayoutEffect()的区别? <a class="header-anchor" href="#useeffect-与-uselayouteffect-的区别" aria-label="Permalink to &quot;useEffect()与 useLayoutEffect()的区别?&quot;">​</a></h3><ul><li>useEffect 不会 block 浏览器渲染,而 useLayoutEffect 会阻塞浏览器渲染。</li><li>useEffect 会在浏览器渲染结束后执行,useLayoutEffect 则是在 DOM 更新完成后,浏览器绘制之前执行,</li></ul><h3 id="useeffect-fn-与-componentdidmount-的区别" tabindex="-1">useEffect(fn,[])与 componentDidMount()的区别? <a class="header-anchor" href="#useeffect-fn-与-componentdidmount-的区别" aria-label="Permalink to &quot;useEffect(fn,[])与 componentDidMount()的区别?&quot;">​</a></h3><h3 id="react-fiber-是什么-它解决了什么问题" tabindex="-1">React Fiber 是什么?它解决了什么问题? <a class="header-anchor" href="#react-fiber-是什么-它解决了什么问题" aria-label="Permalink to &quot;React Fiber 是什么?它解决了什么问题?&quot;">​</a></h3><h3 id="react-的优化" tabindex="-1">React 的优化 <a class="header-anchor" href="#react-的优化" aria-label="Permalink to &quot;React 的优化&quot;">​</a></h3>',39),s=[r];function o(c,n,u,h,d,f){return t(),a("div",null,s)}const S=e(l,[["render",o]]);export{m as __pageData,S as default};
